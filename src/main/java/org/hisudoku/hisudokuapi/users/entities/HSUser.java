package org.hisudoku.hisudokuapi.users.entities;

import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import lombok.Getter;
import lombok.Setter;

import java.util.HashMap;
import java.util.Map;

import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.Field;

//@ToString(exclude = {"password", "id"})
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Document(collection = "users")
public class HSUser {
    // the id of an entity is generated by a database, so it gets changed after the entity is first persisted
    @Id
    @Indexed(unique = true)
    private String id;

    String name;

    @Indexed(unique = true)
    private String email; // a reliable email address whose ownership has been confirmed by the user using an OTT token

    // @Field(name = "inactive_email")
    // private String inactiveEmail; // email entered by the user as a correspondence address, but not activated with an OTT token, so waiting to be activated via OTT

    private String role;

    String password;

    // @Field(name="reset_password_link")
    // String resetPasswordLink;

    // To establish a one-to-many relationship in Spring Boot with MongoDB, you typically use a reference from the child document to the parent document. This can be achieved by including a field in the child document that references the parent document's ID.
    // private List<String> sudokusIds;

    // embeded document
    @Field(name = "account_usage_info")
    private AccountUsageInfo accountUsageInfo;

    @Field(name = "user_settings")
    private Map<String, String> userSettings = new HashMap<>();

    // String resetPasswordLink;

    // @Field(targetType = FieldType.INT32)
    // EnumType myEnumType; // store enum type in db as an int
}

// -------------------------------------------------------------------------------------------------------------------

// Why not to use @Data
// 1. Entities are mutable. Even the id of an entity is generated by a database, so it gets changed after the entity is first persisted. This means there are no fields we can rely on to calculate the hashCode. By default, @EqualsAndHashCode will use all non-static, non-transient fields, but you can modify which fields are used (and even specify that the output of various methods is to be used) by marking type members with @EqualsAndHashCode.Include or @EqualsAndHashCode.Exclude. Once the id is generated (on its first save) the hashCode gets changed. So the HashSet, if the entity was added to some set before being saved in db, can look for the entity in a different bucket and cannot find it. It wouldn’t be an issue if the id was set during the entity object creation (e.g. was a UUID set by the app), but DB-generated ids are more common.
// 2. Any class definition may be annotated with @ToString to let lombok generate an implementation of the toString()method. By default, it'll print your class name, along with each field, in order, separated by commas. These methods call equals()/hashCode()/toString() on every field of an object. This can have an unwanted side-effect for JPA entities: accidentally loading lazy attributes. This can easily harm the application performance. It can also lead to a LazyInitializationException if it happens outside a transaction. @ToString can still be used, but all the lazy fields need to be excluded. This can be achieved by placing @ToString.Exclude on the desired fields, or by using @ToString(onlyExplicitlyIncluded = true) on the class and @ToString.Include on non-lazy fields.
//
// conclusion: @EqualsAndHashCode and @Data should not be used for entities at all
//
// caveat: According to the JPA specification, all entity classes are required to have a public or protected no-argument constructor. Obviously, when @AllArgsConstructor is used the compiler does not generate the default constructor, the same is true for @Builder. Applying @Builder to a class is as if you added @AllArgsConstructor(access = AccessLevel.PACKAGE) to the class and applied the @Builder annotation to this all-args-constructor. So make sure to always use them with @NoArgsConstructor or an explicit no-argument constructor Using @Builder/@AllArgsConstructor for JPA entities without defined no-argument constructor breaks JPA specification.
//
// When working with JPA and Lombok, remember these rules:
//    Avoid using @EqualsAndHashCode and @Data with JPA entities;
//    Always exclude lazy attributes when using @ToString;
//    Don’t forget to add @NoArgsConstructor to entities with @Builder or @AllArgsConstructor.

// -------------------------------------------------------------------------------------------------------------------
// blank value "" vs null vs absence of field
//db.collection.updateOne(
//   { _id: ObjectId("5f5e9e5c9dfb9c7d3e4e44d2") },
//   { $set: { newField: "" } }
//)
// db.collection.updateOne(
//   { _id: ObjectId("5f5e9e5c9dfb9c7d3e4e44d2") },
//   { $set: { field: null } }
//)

// ref: https://www.mydbops.com/blog/null-handling-in-mongodb
// ref: https://www.geeksforgeeks.org/how-to-query-for-is-not-null-in-mongodb-in-a-specific-field/
// ref: https://www.squash.io/adding-a-field-with-blank-value-in-mongodb-query/
// ref: https://www.xuchao.org/docs/mongodb/tutorial/query-for-null-fields.html
//Mongo doesn't work as SQL, where you have to have at least null in every column. If you don't have value, simply don't include the key. Then if you make query for all documents, where this key doesn't exists it will work correctly, otherwise not. Null values are considered as valid values and are included in queries and operations. In MongoDB, "is not null" refers to a condition where a specific field within a document has a value assigned to it meaning the field exists and is not empty or null. A query such as {field: null} will return documents where the field is either explicitly set to null or doesn't exist at all. While this behavior is generally acceptable for most use cases, it can be problematic if you're working with strict data structures and expect more precise results.
// db.collection.find({ field: null })
//This query matches both scenarios: documents where the field is explicitly null and documents where the field is missing entirely. This dual behavior can lead to unexpected results if your goal is to specifically find null values.
//
//If you want to isolate documents where a field exists but holds a null value, you’ll need to combine your query with the $exists operator:
//db.collection.find({ field: null, field: { $exists: true } })
//This query returns documents where the field exists but explicitly holds a null value. This is especially useful in systems where missing fields are a common occurrence.
//
//In MongoDB, you can explicitly insert a null value into a field without any issues:
//db.collection.insert({ field: null })
//
//MongoDB treats null as a valid value. However, from a data modeling perspective, it is essential to determine when to use null versus when to omit a field entirely. In systems that experience frequent schema changes, omitting fields may be the preferable approach to avoid confusion between 'missing' and 'empty' values.
//
//When it comes to sorting, MongoDB treats null as the lowest possible value. This is essential to know when querying and sorting across fields with mixed types or missing data.
//db.collection.find().sort({ field: 1 })
//
//An often overlooked aspect of MongoDB is how it handles null values in indexes. When you create an index on a field that has null or missing values, MongoDB includes those documents in the index. This can have performance implications, especially if your dataset includes many documents with null fields.
//
// db.students.find({ name: { $ne: null } });
// db.collection.find({ field: { $exists: true, $ne: null } });
//
// Null checking in query is rather simple. We can test any field against null. This query will find all accounts not only where field accountId is null, but also where the field doesn't exist.
//db.accounts.find({ accountId : null })
//
//To find accounts where accountId does exist and isn't null, we can use operator $ne - not equals. The second query with operator $eq is equivalent of query above.
//db.accounts.find({ accountId : {$ne : null} })
//db.accounts.find({ accountId : {$eq : null} })
//
//In case we want to check only existence and don't care about null, there is an operator $exists.
//db.accounts.find({ accountId : { $exists: true} })
//
//To conclude,
//    Null behaves as expected when the key exists in our documents.
//    Null also means ‘does not exist’ and so, if we query for a field that does not exist in our document and query for its null value, MongoDB will return all the documents in that collection.
//    It is advised to use $exists to match the documents that contain the field, including documents where the field value is null.
//    $exists typically can also result in lower performance of query and using indexes is highly recommended.

//In aggregation pipelines, handling null values is critical, especially when performing operations like grouping or projecting fields. MongoDB provides several operators to deal with null, the most common being $ifNull.
//
// The stage $match used to filter documents works exactly the same way as query.
// { $match: { accountId : null } }
// { $match: { accountId : {$ne : null}} }
// { $match: { accountId : {$eq : null}} }
// { $match: { accountId : {$exists : true} } }
// { $match: { accountId : {$exists : false} }
//
//In some cases, you don't want to exclude documents from pipeline but rather create a field with value which depends on the existence or null. Using the previous knowledge, we could put together Project stage with null test in condition.
//{ $project: { accountIdFlag : {$cond : [{$eq : ["$accountId", null]}, 0, 1]} }}
//
//My goal here is to create field accountIdFlag which will be 0 if accountId is null or non-existent and 1 if it contains value. However if you run this aggregation, the field will always be 1. We have to choose different strategy in this case.
//{ $project: { accountIdFlag : {$cond : [{$eq : [{ $ifNull: ["$accountId", null]} , null]}, 0, 1]} }}
//
//If the expression in $ifNull evaluates to null or missing field, replacement expression is returned - null. If not, the value is returned. We test the result against null and this time, we get correct flag - 0 if the field is null or missing and 1 if not
//
//Replacing null with a Default Value:
//db.collection.aggregate([
//  { $project: { fieldValue: { $ifNull: ["$field", "defaultValue"] } } }
//])

// -------------------------------------------------------------------------------------------------------------------

//public enum Status {
//    JUNIOR(0),
//    MID(1),
//    SENIOR(2);
//
//    private final int value;
//
//    Status(int value) {
//        this.value = value;
//    }
//    public int getValue() {
//        return value;
//    }
//}

//public class StatusConverter implements Converter<Status, Integer> {
//    @Override
//    public Integer convert(Status source) {
//        return source.getValue();
//    }
//
//    @Override
//    public Status unwrap(Integer source) {
//        return Arrays.stream(Status.values())
//                .filter(status -> status.getValue() == source)
//                .findFirst()
//                .orElseThrow(() -> new IllegalArgumentException("Invalid status value: " + source));
//    }
//}
